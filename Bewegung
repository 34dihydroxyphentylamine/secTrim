#include <iostream>
#include <vector>
#include <string>
#include <cmath>
#include <random>
#include <ctime>
#include <SDL.h>
#include <SDL_image.h>

// Note: Per user request, the includes were requested as #include SDL;
// However, standard C++ requires <SDL.h> for compilation. Using standard includes.

// --- Global Constants ---
const int SCREEN_WIDTH = 800;
const int SCREEN_HEIGHT = 600;
const int PLAYER_W = 64;
const int PLAYER_H = 64;
const int ENEMY_W = 40;
const int ENEMY_H = 40;
const int PLAYER_SPEED = 5;
const int ENEMY_SPEED = 4;
const int MAX_LIVES = 3;

// Forward Declarations
class Entity;
class Player;
class Enemy;

/**
 * @brief Utility function to load a texture from a file.
 * @param renderer The SDL_Renderer to use.
 * @param path The path to the image file.
 * @return The loaded SDL_Texture, or nullptr on failure.
 */
SDL_Texture* loadTexture(SDL_Renderer* renderer, const std::string& path) {
    SDL_Texture* newTexture = IMG_LoadTexture(renderer, path.c_str());
    if (newTexture == nullptr) {
        std::cerr << "Warning: Failed to load texture " << path << "! SDL_image Error: " << IMG_GetError() << std::endl;
        
    }
    return newTexture;
}

/**
 * @brief Simple Axis-Aligned Bounding Box (AABB) collision detection.
 */
bool checkCollision(int x1, int y1, int w1, int h1, int x2, int y2, int w2, int h2) {
    return x1 < x2 + w2 &&
           x1 + w1 > x2 &&
           y1 < y2 + h2 &&
           y1 + h1 > y2;
}

// --- Entity Base Class (for drawing and position) ---

class Entity {
public:
    int x, y;
    int w, h;
    SDL_Texture* currentTexture;

    Entity(int x_in, int y_in, int w_in, int h_in)
        : x(x_in), y(y_in), w(w_in), h(h_in), currentTexture(nullptr) {}

    virtual ~Entity() {}

    /**
     * @brief Renders the entity's current texture. If no texture is loaded, draws a fallback color square.
     */
    virtual void render(SDL_Renderer* renderer) {
        SDL_Rect renderQuad = {x, y, w, h};
        if (currentTexture) {
            SDL_RenderCopy(renderer, currentTexture, NULL, &renderQuad);
        } else {
            // Fallback: draw a colored square if texture failed to load
            SDL_SetRenderDrawColor(renderer, 0xFF, 0x00, 0xFF, 0xFF); // Magenta fallback
            SDL_RenderFillRect(renderer, &renderQuad);
        }
    }
};

// --- Player Class ---

class Player : public Entity {
private:
    std::vector<SDL_Texture*> animationFrames;
    SDL_Texture* singleTexture;
    int lives;
    int frameIndex;
    int frameTimer;
    bool isAnimatedMode;
    bool isMouseControlActive;
    bool isAlive;

public:
    Player(SDL_Renderer* renderer, int x_in, int y_in)
        : Entity(x_in, y_in, PLAYER_W, PLAYER_H),
          lives(MAX_LIVES),
          frameIndex(0),
          frameTimer(0),
          isAnimatedMode(true), // Start with animation for demonstration
          isMouseControlActive(false),
          isAlive(true)
    {
        // Load single texture (Option 1)
        singleTexture = loadTexture(renderer, "player_static.png");
        
        // Load animation frames (Option 2)
        animationFrames.push_back(loadTexture(renderer, "player_frame_1.png"));
        animationFrames.push_back(loadTexture(renderer, "player_frame_2.png"));
        
        // Use the first loaded texture as the initial current texture
        if (isAnimatedMode && !animationFrames.empty()) {
            currentTexture = animationFrames[0];
        } else {
            currentTexture = singleTexture;
        }
    }

    ~Player() {
        if (singleTexture) SDL_DestroyTexture(singleTexture);
        for (SDL_Texture* tex : animationFrames) {
            if (tex) SDL_DestroyTexture(tex);
        }
        animationFrames.clear();
    }
    
    int getLives() const { return lives; }
    bool getIsAlive() const { return isAlive; }

    /**
     * @brief Reduces player life and resets position on collision.
     */
    void loseLife() {
        if (lives > 0) {
            lives--;
            x = SCREEN_WIDTH / 2 - w / 2; // Respawn in center
            y = SCREEN_HEIGHT / 2 - h / 2;
            std::cout << "Player hit! Lives remaining: " << lives << std::endl;
        }
        if (lives <= 0) {
            isAlive = false;
            std::cout << "Game Over!" << std::endl;
        }
    }

    /**
     * @brief Toggles between single texture and animated rendering.
     */
    void toggleAnimationMode() {
        isAnimatedMode = !isAnimatedMode;
        std::cout << "Player Mode: " << (isAnimatedMode ? "Animated" : "Static") << std::endl;
    }

    /**
     * @brief Handles movement based on keyboard (ASWD) or mouse.
     */
    void handleInput(const SDL_Event& e) {
        // Toggle animation mode (for demonstration, using 'E')
        if (e.type == SDL_KEYDOWN && e.key.keysym.sym == SDLK_e) {
             toggleAnimationMode();
        }

        // Toggle mouse control activation via Right Mouse Button
        if (e.type == SDL_MOUSEBUTTONDOWN && e.button.button == SDL_BUTTON_RIGHT) {
            isMouseControlActive = true;
        }
        if (e.type == SDL_MOUSEBUTTONUP && e.button.button == SDL_BUTTON_RIGHT) {
            isMouseControlActive = false;
        }
    }

    /**
     * @brief Updates player position (manual or mouse) and animation frame.
     */
    void update() {
        if (!isAlive) return;

        // --- Keyboard Control (ASWD) ---
        const Uint8* currentKeyStates = SDL_GetKeyboardState(NULL);
        if (!isMouseControlActive) {
            if (currentKeyStates[SDL_SCANCODE_W]) y -= PLAYER_SPEED;
            if (currentKeyStates[SDL_SCANCODE_S]) y += PLAYER_SPEED;
            if (currentKeyStates[SDL_SCANCODE_A]) x -= PLAYER_SPEED;
            if (currentKeyStates[SDL_SCANCODE_D]) x += PLAYER_SPEED;
        }

        // --- Mouse Control (Right Click + Follow) ---
        if (isMouseControlActive) {
            int mouseX, mouseY;
            SDL_GetMouseState(&mouseX, &mouseY);
            
            // Calculate direction vector to cursor center
            float dx = (float)mouseX - (x + w / 2);
            float dy = (float)mouseY - (y + h / 2);

            // Calculate distance to stop close to the cursor
            float distance = std::sqrt(dx * dx + dy * dy);

            if (distance > PLAYER_SPEED) {
                // Normalize and move
                float angle = std::atan2(dy, dx);
                x += (int)(PLAYER_SPEED * std::cos(angle));
                y += (int)(PLAYER_SPEED * std::sin(angle));
            } else {
                // Stop close to target
                x = mouseX - w / 2;
                y = mouseY - h / 2;
            }
        }

        // Keep player in bounds
        if (x < 0) x = 0;
        if (x > SCREEN_WIDTH - w) x = SCREEN_WIDTH - w;
        if (y < 0) y = 0;
        if (y > SCREEN_HEIGHT - h) y = SCREEN_HEIGHT - h;

        // --- Animation Update (Option 2) ---
        if (isAnimatedMode) {
            if (animationFrames.empty()) {
                currentTexture = singleTexture; // Fallback if animated frames didn't load
                return;
            }

            frameTimer++;
            // Update frame every 2 game loop cycles (approx 1/30s at 60 FPS, close to 1/25s)
            if (frameTimer >= 2) { 
                frameTimer = 0;
                frameIndex = (frameIndex + 1) % animationFrames.size();
                currentTexture = animationFrames[frameIndex];
            }
        } else {
            // Static Mode (Option 1)
            currentTexture = singleTexture;
        }
    }

    // Inherited render method is sufficient
};

// --- Enemy Class ---

class Enemy : public Entity {
private:
    float velX, velY;
    std::mt19937 generator;
    std::uniform_real_distribution<> distribution;
    bool isDestroyed;

public:
    Enemy(SDL_Renderer* renderer, int x_in, int y_in)
        : Entity(x_in, y_in, ENEMY_W, ENEMY_H),
          velX(0), velY(0),
          isDestroyed(false)
    {
        // Initialize random generator
        generator.seed(time(0));
        distribution = std::uniform_real_distribution<>(-1.0, 1.0);

        // Load texture and set initial random velocity
        currentTexture = loadTexture(renderer, "enemy.png");
        setRandomVelocity();
    }

    ~Enemy() {
        if (currentTexture) SDL_DestroyTexture(currentTexture);
    }

    bool isAlive() const { return !isDestroyed; }
    void destroy() { isDestroyed = true; }

    /**
     * @brief Sets a new random velocity vector.
     */
    void setRandomVelocity() {
        float angle = distribution(generator) * M_PI * 2; // Random angle from 0 to 2*PI
        velX = ENEMY_SPEED * std::cos(angle);
        velY = ENEMY_SPEED * std::sin(angle);
    }

    /**
     * @brief Updates enemy position and handles bouncing off the walls.
     */
    void update() {
        if (isDestroyed) return;

        // Move
        x += (int)velX;
        y += (int)velY;

        // Bounce horizontally
        if (x < 0 || x + w > SCREEN_WIDTH) {
            velX *= -1; // Reverse X direction
            // Keep within bounds to prevent sticky movement
            if (x < 0) x = 0;
            if (x + w > SCREEN_WIDTH) x = SCREEN_WIDTH - w;
        }

        // Bounce vertically
        if (y < 0 || y + h > SCREEN_HEIGHT) {
            velY *= -1; // Reverse Y direction
            // Keep within bounds
            if (y < 0) y = 0;
            if (y + h > SCREEN_HEIGHT) y = SCREEN_HEIGHT - h;
        }
    }

    /**
     * @brief Renders the enemy only if it is not destroyed.
     */
    void render(SDL_Renderer* renderer) override {
        if (!isDestroyed) {
            Entity::render(renderer);
        }
    }
};

// --- Game Manager Class ---

class Game {
private:
    SDL_Window* window;
    SDL_Renderer* renderer;
    Player* player;
    Enemy* enemy;
    bool isRunning;

public:
    Game() : window(nullptr), renderer(nullptr), player(nullptr), enemy(nullptr), isRunning(false) {}

    /**
     * @brief Initializes SDL, the window, and renderer.
     */
    bool init() {
        if (SDL_Init(SDL_INIT_VIDEO) < 0) {
            std::cerr << "SDL could not initialize! SDL Error: " << SDL_GetError() << std::endl;
            return false;
        }

        if (!(IMG_Init(IMG_INIT_PNG) & IMG_INIT_PNG)) {
            std::cerr << "SDL_image could not initialize! SDL_image Error: " << IMG_GetError() << std::endl;
            // Not critical, fallback drawing will be used
        }

        window = SDL_CreateWindow("C++ SDL2 Entity Game", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);
        if (window == nullptr) {
            std::cerr << "Window could not be created! SDL Error: " << SDL_GetError() << std::endl;
            return false;
        }

        renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
        if (renderer == nullptr) {
            std::cerr << "Renderer could not be created! SDL Error: " << SDL_GetError() << std::endl;
            return false;
        }

        // Instantiate entities
        player = new Player(renderer, SCREEN_WIDTH / 4, SCREEN_HEIGHT / 2);
        enemy = new Enemy(renderer, SCREEN_WIDTH * 3 / 4, SCREEN_HEIGHT / 2);

        isRunning = true;
        return true;
    }

    /**
     * @brief Main game loop.
     */
    void run() {
        SDL_Event e;
        // Game loop timing variables
        const int TARGET_FPS = 60;
        const int FRAME_DELAY = 1000 / TARGET_FPS;
        Uint32 frameStart;
        int frameTime;

        while (isRunning) {
            frameStart = SDL_GetTicks();

            // --- 1. Handle Events ---
            while (SDL_PollEvent(&e) != 0) {
                if (e.type == SDL_QUIT) {
                    isRunning = false;
                }
                player->handleInput(e);
            }

            // --- 2. Update Game State ---
            if (player->getIsAlive()) {
                player->update();
                enemy->update();
                checkGameLogic();
            } else {
                // Stop the game if player is not alive (optional: add a game over screen)
                // For simplicity, we just stop updates here.
            }

            // --- 3. Render ---
            SDL_SetRenderDrawColor(renderer, 0x1A, 0x1A, 0x33, 0xFF); // Dark background
            SDL_RenderClear(renderer);

            player->render(renderer);
            enemy->render(renderer);
            
            // Render player lives
            renderLives();

            SDL_RenderPresent(renderer);

            // --- 4. Frame Limiting ---
            frameTime = SDL_GetTicks() - frameStart;
            if (FRAME_DELAY > frameTime) {
                SDL_Delay(FRAME_DELAY - frameTime);
            }
        }
    }

    /**
     * @brief Checks for collisions and game events.
     */
    void checkGameLogic() {
        if (!enemy->isAlive()) return;

        if (checkCollision(player->x, player->y, player->w, player->h,
                           enemy->x, enemy->y, enemy->w, enemy->h))
        {
            // Collision occurred!
            player->loseLife();
            enemy->destroy(); // Enemy disappears

            // Optional: Create a new enemy after a short delay or event
            // For this example, we'll just destroy the enemy.
            std::cout << "Enemy destroyed by player." << std::endl;
        }
    }

    /**
     * @brief Draws the remaining lives on screen (simple rectangles).
     */
    void renderLives() {
        SDL_SetRenderDrawColor(renderer, 0xFF, 0x00, 0x00, 0xFF); // Red color for hearts/lives
        int currentLives = player->getLives();
        for (int i = 0; i < currentLives; ++i) {
            SDL_Rect lifeRect = {10 + i * 30, 10, 20, 20}; // Draw a 20x20 square for each life
            SDL_RenderFillRect(renderer, &lifeRect);
        }
    }

    /**
     * @brief Cleans up SDL resources.
     */
    void close() {
        delete player;
        delete enemy;

        SDL_DestroyRenderer(renderer);
        SDL_DestroyWindow(window);
        window = nullptr;
        renderer = nullptr;

        IMG_Quit();
        SDL_Quit();
        std::cout << "Game closed successfully." << std::endl;
    }
};

/**
 * @brief Main function.
 */
int main(int argc, char* args[]) {
    // Check if the cos function requires explicit linking to math library (M_PI)
    // If M_PI is undefined, use 3.14159f instead. M_PI is defined in cmath.
    
    Game game;
    if (game.init()) {
        game.run();
    }
    game.close();

    return 0;
}

